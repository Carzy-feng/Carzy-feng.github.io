<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>恶意代码分析实战-day5(高级静态分析)</title>
    <link href="/2022/05/10/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day5(%E9%AB%98%E7%BA%A7%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90)/"/>
    <url>/2022/05/10/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day5(%E9%AB%98%E7%BA%A7%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90)/</url>
    
    <content type="html"><![CDATA[<p>学习《恶意代码分析实战》一书时，跟随书本所做的练习。</p><h2 id="Lab-7-1"><a href="#Lab-7-1" class="headerlink" title="Lab 7-1"></a>Lab 7-1</h2><p>​分析在文件Lab’07-01.exe中发现的恶意代码。</p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><h5 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205031954766.png" alt="image-20220503195408415"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205031954835.png" alt="image-20220503195424728"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205031954058.png" alt="image-20220503195440667"></p><h5 id="整体调用"><a href="#整体调用" class="headerlink" title="整体调用"></a>整体调用</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205031956019.png" alt="image-20220503195627340"></p><h5 id="完整分析"><a href="#完整分析" class="headerlink" title="完整分析"></a>完整分析</h5><p>查看main，程序调用了<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicectrldispatchera">StarServiceCtrlDispatcherA</a>说明这个程序是一个服务。服务执行<code>sub_401040</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032124947.png" alt="image-20220503212409769"></p><p>sub_401040：使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openmutexw">OpenMutexA</a>检测互斥锁名称<code>HGL345</code>,如果存在则退出程序，不过不存在则跳转到<code>loc_401064</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032128663.png" alt="image-20220503212835848"></p><p>loc_401064：</p><ul><li><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa">CreateMutexA</a>创建一个互斥锁<code>HGL345</code>，然后使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a>与服务控制管理器建立连接。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032135608.png" alt="image-20220503213323773"></p></li><li><p>然后使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea">GetModuleFileName</a>获取当前程序的路径,并将该路径设置为<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateServiceA</a>创建的名为<code>Malservice</code>服务的二进制文件路径，注意创建服务时，该服务的StartType是0x02，即该服务是自启动服务，由此达成持久化驻留。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032143906.png" alt="image-20220503214352584"></p></li><li><p>然后清空edx寄存器，然后将<code>SystemTime</code>的各项值都设为0，但在使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-systemtimetofiletime">SystemTimeToFileTime</a>转换时间格式之前将<code>SystemTime.wYear</code>的值设为0x834(2100)，所以最后得到的时间为2100年1月1日0时0分0秒，注意该值是赋予<code>FileTime</code>变量的。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032154584.png" alt="image-20220503215457627"></p></li><li><p>接着使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw">CreateWaitableTimer</a>创建一个计时器对象，由于计时器最初是不活动的，需要使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer">SetWaitableTimer</a>激活计时器，计时器发出信号的时间为<code>FileTime</code>(2100.1.1 00:00:00)。接着调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a>等待指定时间到达，等待的超时时间为<code>0x0FFFFFFFF</code>（几乎不可能）。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032202837.png" alt="image-20220503220215489"></p></li><li><p>然后循环0x14次（20次），循环的内容为使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread</a>创建线程，然后<code>Sleep(0xFFFFFFFF)</code>(这辈子都在sleep了)</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032213117.png" alt="image-20220503221350750"></p></li></ul><p>这时候我们查看线程函数StartAddress：</p><ul><li><p>使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena">InternetOpenA</a>初始化UA为<code>Internet Explorer 8.0</code>,然后循环使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA</a>请求网址<code>http://www.malwareanalysisbook.com</code>。注意之前sleep的线程是主线程。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205032218174.png" alt="image-20220503221847114"></p></li></ul><h4 id="1、当计算机重启后，这个程序如何确保它继续运行-达到持久化驻留-？"><a href="#1、当计算机重启后，这个程序如何确保它继续运行-达到持久化驻留-？" class="headerlink" title="1、当计算机重启后，这个程序如何确保它继续运行(达到持久化驻留)？"></a>1、当计算机重启后，这个程序如何确保它继续运行(达到持久化驻留)？</h4><p>以自启动的方式创建一个名为<code>Malservice</code>的服务。</p><h4 id="2、为什么这个程序会使用一个互斥量？"><a href="#2、为什么这个程序会使用一个互斥量？" class="headerlink" title="2、为什么这个程序会使用一个互斥量？"></a>2、为什么这个程序会使用一个互斥量？</h4><p>有上面的分析可得知，是为了检测当前主机是否已经运行了该程序(服务)。</p><h4 id="3、可以用来检测这个程序的基于主机特征是什么？"><a href="#3、可以用来检测这个程序的基于主机特征是什么？" class="headerlink" title="3、可以用来检测这个程序的基于主机特征是什么？"></a>3、可以用来检测这个程序的基于主机特征是什么？</h4><p>查看该主机是否有一个名为<code>Malservice</code>的服务进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">net start   <span class="hljs-regexp">//</span>查看服务命令<br></code></pre></td></tr></table></figure><h4 id="4、检测这个恶意代码的基于网络特征是是什么？"><a href="#4、检测这个恶意代码的基于网络特征是是什么？" class="headerlink" title="4、检测这个恶意代码的基于网络特征是是什么？"></a>4、检测这个恶意代码的基于网络特征是是什么？</h4><p>请求url<code>http://www.malwareanalysisbook.com</code>且请求时的UA为<code>Internet Explorer 8.0</code></p><h4 id="5、这个程序的目的是什么？"><a href="#5、这个程序的目的是什么？" class="headerlink" title="5、这个程序的目的是什么？"></a>5、这个程序的目的是什么？</h4><p>循环请求一个网址，且没有之前的解析网页的操作，那么该程序有可能是一个DOS程序</p><h4 id="6、这个程序什么时候完成？"><a href="#6、这个程序什么时候完成？" class="headerlink" title="6、这个程序什么时候完成？"></a>6、这个程序什么时候完成？</h4><p>由于该程序存在一个死循环，所以该程序永远不会完成。</p><h2 id="Lab-7-2"><a href="#Lab-7-2" class="headerlink" title="Lab 7-2"></a>Lab 7-2</h2><p>​分析在文件Lab07-02.exe中发现的恶意代码。</p><h4 id="基础静态分析"><a href="#基础静态分析" class="headerlink" title="基础静态分析"></a>基础静态分析</h4><h5 id="导入表-1"><a href="#导入表-1" class="headerlink" title="导入表"></a>导入表</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041402579.png" alt="image-20220504140211566"></p><h5 id="整体调用-1"><a href="#整体调用-1" class="headerlink" title="整体调用"></a>整体调用</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041401548.png" alt="image-20220504140130225"></p><h5 id="完整分析-1"><a href="#完整分析-1" class="headerlink" title="完整分析"></a>完整分析</h5><p>查看main：</p><ul><li><p>首先调用了<a href="https://docs.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-oleinitialize">OleInitialize</a>初始化COM库。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041405758.png" alt="image-20220504140539892"></p></li><li><p>接着调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance</a>初始化COM对象，IDA Pro将返回的COM对象标记为ppv。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041412764.png" alt="image-20220504141240518"></p></li><li><p>下面两张图显示了初始化COM对象的iid以及clsid的值。iid表示：IWebBrowser2接口，clsid表示：Internet Explorer</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041437473.png" alt="image-20220504143654217"></p></li><li><p>然后将着调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-variantinit">VariantInit</a>初始化一个变体(<a href="https://baike.baidu.com/item/Variant/4668832">Varian数据类型</a>)，并使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-sysallocstring">SysAllocString</a>复制一个字符串<code>http://www.malwareanalysisbook.com/ad.html</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041426174.png" alt="image-20220504142607875"></p></li><li><p>在下面的程序中，在调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-sysfreestring">SysFreeString</a>释放之前复制的字符串，还存在一个<code>call dword ptr [edx+2Ch]</code>的调用，有edx的值是ppv（COM对象），由上面我们可以得知COM对象调用的是IWebBrowser2接口，该条命令即是调用IWebBrowser2+0x2C处的函数。那么我们就要添加IWebBrowser2结构体。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041504445.png" alt="image-20220504150415290"></p><ul><li><p>添加结构体：进入shift+F9然后按Insert，然后Add standard structure –&gt; search 搜索 IWebBrowser2–&gt;IWebBrowser2Vb1，接着再[edx+2Ch]处加载结构体即可</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041508496.png" alt="image-20220504150810558"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041510145.png" alt="image-20220504151006359"></p></li></ul></li><li><p>我们可以知道该处调用的是<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.uii.csr.browser.web.iwebbrowser2.navigate?view=dynamics-usd-3#microsoft-uii-csr-browser-web-iwebbrowser2-navigate(system-string-system-object@-system-object@-system-object@-system-object@)">IWeb Browser2.Navigate</a>，然后打开的URL是之前复制的字符串<code>http://www.malwareanalysisbook.com/ad.html</code>，打开完该网页后就释放该字符串，然后调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-oleuninitialize">OleUninitialize</a>关闭COM对象。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041518568.png" alt="image-20220504151825479"></p></li></ul><h4 id="1、这个程序如何完成持久化驻留？"><a href="#1、这个程序如何完成持久化驻留？" class="headerlink" title="1、这个程序如何完成持久化驻留？"></a>1、这个程序如何完成持久化驻留？</h4><p>这个程序是一次性的，不存再持久化。</p><h4 id="2、这个程序的目的是什么？"><a href="#2、这个程序的目的是什么？" class="headerlink" title="2、这个程序的目的是什么？"></a>2、这个程序的目的是什么？</h4><p>打开<code>http://www.malwareanalysisbook.com/ad.html</code>。</p><h4 id="3、这个程序什么时候完成执行？"><a href="#3、这个程序什么时候完成执行？" class="headerlink" title="3、这个程序什么时候完成执行？"></a>3、这个程序什么时候完成执行？</h4><p>打开完网页后就完成执行。</p><h2 id="Lab-7-3"><a href="#Lab-7-3" class="headerlink" title="Lab 7-3"></a>Lab 7-3</h2><p>​分析Lab07-03.exe以及Lab07-03.dll（运行这个程序时，需确保这两个文件在同一个目录，并且运行前需拍摄快照）</p><h4 id="基础静态分析-1"><a href="#基础静态分析-1" class="headerlink" title="基础静态分析"></a>基础静态分析</h4><p>整体调用的内容有点多，我就不放了</p><h5 id="导入表-2"><a href="#导入表-2" class="headerlink" title="导入表"></a>导入表</h5><h6 id="Lab07-03-exe"><a href="#Lab07-03-exe" class="headerlink" title="Lab07-03.exe"></a>Lab07-03.exe</h6><p>根据CopyFileA、CreateFileA、CreateFileMappingA、MapView0fFile可以得知，该程序会进行文件操作。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041523224.png" alt="image-20220504152312236"></p><h6 id="Lab07-03-dll"><a href="#Lab07-03-dll" class="headerlink" title="Lab07-03.dll"></a>Lab07-03.dll</h6><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101452934.png" alt="image-20220510145236319"></p><h5 id="完整分析-2"><a href="#完整分析-2" class="headerlink" title="完整分析"></a>完整分析</h5><h6 id="分析exe"><a href="#分析exe" class="headerlink" title="分析exe"></a>分析exe</h6><p>查看main：</p><ul><li><p>首先判断输入的参数是不是等于2个。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041636578.png" alt="image-20220504163637818"></p></li><li><p>然后将字符串<code>WARNING_THIS_WILL_DESTROY_YOUR_MACHINE</code>赋予esi，以及将第二个参数[eax+4]赋予eax，然后进入到<code>loc_401460</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041640963.png" alt="image-20220504164000223"></p></li></ul><p>查看loc_401460：</p><ul><li><p>将ESI的值与EAX的值进行对比，如果内容不一样则退出程序。如果一致则会跳转到<code>loc_40148D</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041644062.png" alt="image-20220504164446965"></p></li></ul><p>查看loc_40148D：</p><ul><li><p>调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFileA</a>创建<code>C:\\Windows\\System32\\Kernel32.dll</code>,然后调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMappingA</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a>将其映射到内存。这里将kernel32.dll的句柄赋值给<code>hObject</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041658693.png" alt="image-20220504165809582"></p></li><li><p>接着打开<code>Lab07-03.dll</code>,这里的EAX是Kernel32.dll的内存地址，将其赋值给了argc</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041702746.png" alt="image-20220504170229509"></p></li><li><p>接着将Lab07-03.dll的句柄赋值给<code>var_4</code>,然后调用<code>loc_401503</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041707058.png" alt="image-20220504170755934"></p></li></ul><p>查看loc_401503：调用<code>loc_401518</code>这两个函数的作用就是将Lab07-03.dll映射进内存，然后将该内存地址赋值给argv,最后调用<code>loc_401538</code></p><p>​<img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041712725.png" alt="image-20220504171224615"></p><p>由于后面的都是一连串很繁琐的代码，我直接跳到下一个调用windows API的地方</p><p>查看loc_4017D4：</p><ul><li><p>首先调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle</a>关闭Kernel32.dll的句柄,然后关闭Lab07-03.dll的句柄，接着调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilea">CopyFileA</a>将<code>Lab07-03.dll</code>复制到<code>C:\\windows\\system32\\kerne132.dll</code>，然后进入<code>loc_401806</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041728123.png" alt="image-20220504172835252"></p></li></ul><p>查看loc_401806：将<code>C:\\*</code>压入栈中，然后调用<code>sub_4011E0</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041730131.png" alt="image-20220504172959095"></p><p>查看sub_4011E0：</p><ul><li><p>调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a>来搜索C盘下所有文件，这里将搜索到的文件句柄赋值给<code>hFindFile</code>，然后就是一连串繁琐的代码，我们直接进入到下一个存在windows API函数的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205041739867.png" alt="image-20220504173859151"></p></li></ul><p>下一个存在windows API函数的的位置是<code>loc_40135C</code></p><p>查看loc_40135C：</p><ul><li><p>调用<a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/stricmp-wcsicmp-mbsicmp-stricmp-l-wcsicmp-l-mbsicmp-l?view=msvc-170">_stricmp</a>来查找对exe文件进行匹配，也就是对比文件名。对比文件结束后执行了一条<code>call sub_4010A0</code>命令，还在调用该函数前将EBP压入栈。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205042144201.png" alt="image-20220504214407144"></p><p>—-分割线（上图可知ebx的值是Reserved1）</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205042141032.png" alt="image-20220504214126913"></p></li><li><p>我们继续分析这层函数，再这层函数的底部发现了一条<code>jmp loc_401210</code>，跳转到了第一次进行一系列的繁琐操作开头。由此可得知该函数是循环查找C盘下所有文件</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205042153835.png" alt="image-20220504215342412"></p></li></ul><p>查看sub_4010A0：</p><ul><li><p>调用，将ebp压入栈中，这里的IDA将其识别为FileName</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205042211461.png" alt="image-20220504221104198"></p></li><li><p>正式进入sub_4010A0，还是和之前一样，将整个文件映射进入内存</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205042215065.png" alt="image-20220504221526144"></p></li><li><p>然后调用很多<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadreadptr">IsBadReadPtr</a>验证指针是否有效，再往下看就会看到一个<code>_stricmp</code>检测字符串的值是不是<code>kernel32.dll</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101412587.png" alt="image-20220510141208482"></p></li><li><p>接着进入到再缓冲区中搜索字符串的环节，注意第三行的<code>repne scasb</code>，其中第一行的edi是指向的缓冲区地址，eax是要搜索的字符串，ecx为缓冲区长度，当ecx&#x3D;0或找到该字符串时，比较停止。</p><ul><li>这里的地址是ebx，而ebx是再上面的被压入<code>_stricmp</code>的Str1</li><li>下面的<code>rep movsd</code>也是同理，将<code>dword_403010</code>复制到<code>edi</code>中，使用<code>kerne132.dll</code>替换掉<code>kernel32.dll</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101424274.png" alt="image-20220510142404370"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101437559.png" alt="image-20220510143753042"></p></li></ul><h6 id="分析DLL"><a href="#分析DLL" class="headerlink" title="分析DLL"></a>分析DLL</h6><p>字符串列表</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101451567.png" alt="image-20220510145124485"></p><p>查看main：</p><ul><li><p>分配一个栈空间</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101455438.png" alt="image-20220510145458355"></p></li><li><p>通过OpenMutexA和CreateMutexA保证只存在一个互斥量<code>SADFHUHF</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101456837.png" alt="image-20220510145640552"></p></li><li><p>接着建立一个socket连接，IP为<code>127.26.152.13</code>,端口为<code>0x50（80）</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101459086.png" alt="image-20220510145938970"></p></li><li><p>接着来到发送数据的环节<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send">send</a>,发送一个<code>hello</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101505453.png" alt="image-20220510150544839"></p><ul><li><p>在往下看，来到接受数据的环节<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv">recv</a>,<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strncmp-wcsncmp-mbsncmp-mbsncmp-l?view=msvc-170">strncmp</a>检测接受到的前五个字符是不是<code>sleep</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101512229.png" alt="image-20220510151235808"></p><ul><li><p>如果是的话，就sleep 60秒，sleep结束后，又回到了接受数据环节。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101515107.png" alt="image-20220510151537152"></p></li></ul></li><li><p>如果不是的话，则检测前四个字符是不是<code>exec</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101514232.png" alt="image-20220510151443152"></p><ul><li><p>当前四个字符是<code>exec</code>时，<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessA</a>,创建一个进程及主线程，由于第一个参数为0，所有<code>lpCommandLine</code>的值，应该为一个程序的绝对路径。即<code>exec 绝对路径</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202205101532111.png" alt="image-20220510153229918"></p></li></ul></li></ul><h4 id="1、这个程序如如何完成持久化驻留，来确保在计算机被重启后他能继续运行？"><a href="#1、这个程序如如何完成持久化驻留，来确保在计算机被重启后他能继续运行？" class="headerlink" title="1、这个程序如如何完成持久化驻留，来确保在计算机被重启后他能继续运行？"></a>1、这个程序如如何完成持久化驻留，来确保在计算机被重启后他能继续运行？</h4><p>这个程序通过将lab07-03.dll复制到<code>C:\\windows\\system32\\kerne132.dll</code>,然后替换C盘下所有加载有<code>kernel32.dll</code>的exe，将其替换为加载<code>kerne132.exe</code></p><h4 id="2、这个恶意代码的两个明显的基于主机特征是什么？"><a href="#2、这个恶意代码的两个明显的基于主机特征是什么？" class="headerlink" title="2、这个恶意代码的两个明显的基于主机特征是什么？"></a>2、这个恶意代码的两个明显的基于主机特征是什么？</h4><p>文件<code>C:\\windows\\system32\\kerne132.dll</code>，以及一个<code>SADFHUHF</code>的互斥量</p><h4 id="3、这个程序的目的是什么？"><a href="#3、这个程序的目的是什么？" class="headerlink" title="3、这个程序的目的是什么？"></a>3、这个程序的目的是什么？</h4><p>创建一个后门。该后门存在与所有加载有<code>Kerenl32.dll</code>的exe文件中。该后门拥有两个功能，一个执行命令功能，一个sleep功能</p><h4 id="4、一旦这个恶意代码被安装，你如何移除它？"><a href="#4、一旦这个恶意代码被安装，你如何移除它？" class="headerlink" title="4、一旦这个恶意代码被安装，你如何移除它？"></a>4、一旦这个恶意代码被安装，你如何移除它？</h4><p>1、写一个程序，将系统中加载<code>kerne132.dll</code>的exe，改为加载<code>kernel32.dll</code>。</p><p>2、修改该程序中的<code>kerne132.dll</code>为<code>kerenl32.dll</code>，然后执行程序即可</p><p>2、将<code>keren132.dll</code>替换为<code>kerenl32.dll</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码分析实战-day4(高级静态分析)</title>
    <link href="/2022/04/29/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day4(%E9%AB%98%E7%BA%A7%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90)/"/>
    <url>/2022/04/29/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day4(%E9%AB%98%E7%BA%A7%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90)/</url>
    
    <content type="html"><![CDATA[<p>学习《恶意代码分析实战》一书时，跟随书本所做的练习。</p><h2 id="Lab-6-1"><a href="#Lab-6-1" class="headerlink" title="Lab 6-1"></a>Lab 6-1</h2><p>​在这个实验中，你将分析在文件Lab06-01.exe中发现的恶意代码。</p><h4 id="基础静态分析"><a href="#基础静态分析" class="headerlink" title="基础静态分析"></a>基础静态分析</h4><h5 id="运行文件结果"><a href="#运行文件结果" class="headerlink" title="运行文件结果"></a>运行文件结果</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271511916.png" alt="image-20220427151124988"></p><h5 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h5><p>​调用<code>InternetGetConnectedState</code>判断能不能出网，当能出网时，返回1，否则返回0</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271512691.png" alt="image-20220427151222669"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271512425.png" alt="image-20220427151240921"></p><h4 id="1、由-main-函数调用的唯一子过程中发现的主要代码结构是什么？"><a href="#1、由-main-函数调用的唯一子过程中发现的主要代码结构是什么？" class="headerlink" title="1、由 main 函数调用的唯一子过程中发现的主要代码结构是什么？"></a>1、由 main 函数调用的唯一子过程中发现的主要代码结构是什么？</h4><p>​唯一子过程是 <code>sub_401000</code>,该子过程是代码是结构是if结构。</p><p>main函数</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271500200.png" alt="image-20220427150014839"></p><p>sub_401000</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271501484.png" alt="image-20220427150112460"></p><h4 id="2、位于0x40105F的子过程是什么？"><a href="#2、位于0x40105F的子过程是什么？" class="headerlink" title="2、位于0x40105F的子过程是什么？"></a>2、位于<code>0x40105F</code>的子过程是什么？</h4><p>​定位到<code>0x40105F</code>，但没看懂是什么，然后查找交叉引用，发现都在<code>sub40105F</code>的分支中调用，且调用前都压入了一个字符串，其中一个字符串与我们之前运行文件时输出的内容一样，由此得知，该子过程是一个print函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271518732.png" alt="image-20220427151820447"></p><h4 id="3、这个程序的目的是什么？"><a href="#3、这个程序的目的是什么？" class="headerlink" title="3、这个程序的目的是什么？"></a>3、这个程序的目的是什么？</h4><p>​再次会到main函数，挨个查看其调用过程，发现唯有<code>sub_401000</code>中调用了windows api函数，由此可以得知该程序的目的是判断当前主机是否能出网。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271501484.png" alt="image-20220427150112460"></p><h2 id="Lab-6-2"><a href="#Lab-6-2" class="headerlink" title="Lab 6-2"></a>Lab 6-2</h2><p>​分析在文件Lab06-02.exe中发现的恶意代码。</p><h4 id="基础静态分析-1"><a href="#基础静态分析-1" class="headerlink" title="基础静态分析"></a>基础静态分析</h4><h5 id="运行文件结果-1"><a href="#运行文件结果-1" class="headerlink" title="运行文件结果"></a>运行文件结果</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271523813.png" alt="image-20220427152353606"></p><h5 id="导入表-1"><a href="#导入表-1" class="headerlink" title="导入表"></a>导入表</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271524370.png" alt="image-20220427152426399"></p><h5 id="整体调用"><a href="#整体调用" class="headerlink" title="整体调用"></a>整体调用</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271526003.png" alt="image-20220427152614101"></p><h4 id="1、main函数调用的第一个子过程执行了什么操作？"><a href="#1、main函数调用的第一个子过程执行了什么操作？" class="headerlink" title="1、main函数调用的第一个子过程执行了什么操作？"></a>1、main函数调用的第一个子过程执行了什么操作？</h4><p>​main 函数的第一个子过程是<code>sub_401000</code>,根据运行结果来看，仍然是判断当前主机能否出网。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271527826.png" alt="image-20220427152740108"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271528122.png" alt="image-20220427152839115"></p><h4 id="2、位于0x40117F的子过程是什么？"><a href="#2、位于0x40117F的子过程是什么？" class="headerlink" title="2、位于0x40117F的子过程是什么？"></a>2、位于<code>0x40117F</code>的子过程是什么？</h4><p>​和Lab6-1一样的判断方法，sub_40117F是一个print函数</p><h4 id="3、被-main-函数调用的第二个子过程做了什么？"><a href="#3、被-main-函数调用的第二个子过程做了什么？" class="headerlink" title="3、被 main 函数调用的第二个子过程做了什么？"></a>3、被 main 函数调用的第二个子过程做了什么？</h4><p>​第二个子过程<code>loc_401148</code>,调用了<code>sub_401040</code>，在最后跳转到<code>loc_40115C</code>,</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271533258.png" alt="image-20220427153342856"></p><p>sub_401040中调用了<a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena">InternetOpenA</a>,以<code>Internet Explorer 7.5/pma</code>作User Agent参数，然后调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA</a>打开<code>http://www.practicalmalwareanalysis.com/cc.htm</code>，如果访问url成功则进入<code>lo_40109D</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271534137.png" alt="image-20220427153406886"></p><p>loc_40109D中调用了<a href="https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile">InternetReadFile</a>读取前200个字节，然后进入<code>loc_4010E5</code>将内容进行一连串比较</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271545258.png" alt="image-20220427154534363"></p><p>loc_4010E5,将比较的内容转为成字符就是<code>&lt;!--</code>，</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291549614.png" alt="image-20220427155927803"></p><p>然后将<code>&lt;!--</code>的第一个字符内容就会被赋值到AL寄存器，然后返回<code>sub_401040</code>。</p><p>ps：这里由于ida识别buffer错误，我将buffer的大小改为512</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271606515.png" alt="image-20220427160627317"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271614370.png" alt="image-20220427161447480"></p><p>可以得知该子过程就是循环获取html文件中<code>&lt;!--</code>后面的内容。该内容可以为恶意指令之类的</p><h4 id="4、在这个子过程中使用了什么类型的代码结构？"><a href="#4、在这个子过程中使用了什么类型的代码结构？" class="headerlink" title="4、在这个子过程中使用了什么类型的代码结构？"></a>4、在这个子过程中使用了什么类型的代码结构？</h4><p>​这个问题我很懵，在第三题的分析中可以得知<code>sub_401040</code>请求了一个url网址，然后判断前四个字符是不是<code>&lt;!--</code>，如果是的话，将第五个字符赋值给al寄存器。</p><h4 id="5、在这个程序中有任何基于网络的指示吗？"><a href="#5、在这个程序中有任何基于网络的指示吗？" class="headerlink" title="5、在这个程序中有任何基于网络的指示吗？"></a>5、在这个程序中有任何基于网络的指示吗？</h4><p>​在第三题中可以指定该程序以<code>Internet Explorer 7.5/pma </code>作为User Agent，去请求<code>http://www.practicalmalwareanalysis.com/cc.htm</code></p><h4 id="6、这个恶意代码的目的是什么？"><a href="#6、这个恶意代码的目的是什么？" class="headerlink" title="6、这个恶意代码的目的是什么？"></a>6、这个恶意代码的目的是什么？</h4><p>​继续第三题的分析，调用<code>sub_401040</code>将请求url网址的第五个字符赋值给al寄存器，然后调用<code>loc_40115C</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271628786.png" alt="image-20220427162759061"></p><p>loc_40115C</p><p>调用<code>sub_40117F</code>将<code>Success: Parsed command is %c\n</code>输出，%c是请求url网址的第五个字符。然后<code>Sleep(0EA60h)</code>（一分钟）</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204271628153.png" alt="image-20220427162844528"></p><h2 id="Lab-6-3"><a href="#Lab-6-3" class="headerlink" title="Lab 6-3"></a>Lab 6-3</h2><p>​在这个实验中，我们会分析在文件Lab06-03.exe中发现的恶意代码。</p><h4 id="基础静态分析-2"><a href="#基础静态分析-2" class="headerlink" title="基础静态分析"></a>基础静态分析</h4><h5 id="导入表-2"><a href="#导入表-2" class="headerlink" title="导入表"></a>导入表</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291358025.png" alt="image-20220429135848816"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291359852.png" alt="image-20220429135903723"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291359429.png" alt="image-20220429135929128"></p><h5 id="整体调用-1"><a href="#整体调用-1" class="headerlink" title="整体调用"></a>整体调用</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291400013.png" alt="image-20220429140041879"></p><h4 id="1、比较在-main-函数与实验6-2的main函数的调用。从-main-中调用的新函数是什么？"><a href="#1、比较在-main-函数与实验6-2的main函数的调用。从-main-中调用的新函数是什么？" class="headerlink" title="1、比较在 main 函数与实验6-2的main函数的调用。从 main 中调用的新函数是什么？"></a>1、比较在 main 函数与实验6-2的main函数的调用。从 main 中调用的新函数是什么？</h4><p>​通过查看Lab 6-2和6-3的整体调用壳得知，在该练习中新增函数是<code>sub_401130</code></p><h4 id="2、这个新的函数使用的参数是什么？"><a href="#2、这个新的函数使用的参数是什么？" class="headerlink" title="2、这个新的函数使用的参数是什么？"></a>2、这个新的函数使用的参数是什么？</h4><p>​根据lab6-2的分析得知，最后从请求url后，将获得的第五个字符赋值给<code>var_8</code>并打印出来，这里我们可以看到<code>sub_401130</code>有两个参数，第一个是argv[0]也就是程序名本身，第二个参数是<code>ecx</code>，但<code>ecx</code>的值是<code>var_8</code>,所以第二个参数是解析html后的第五个字符。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291551705.png" alt="image-20220429155103894"></p><h4 id="3、这个函数包含的主要代码结构是什么？"><a href="#3、这个函数包含的主要代码结构是什么？" class="headerlink" title="3、这个函数包含的主要代码结构是什么？"></a>3、这个函数包含的主要代码结构是什么？</h4><p>​<code>sub_401130</code>：其中<code>arg_0</code>是最后一个压栈的参数，即第五个字符，然后将第五个字符减去61(a)，然后与4进行对比，即检测第五个字符是否是a、b、c、d、e，如果是则跳转到<code>loc_4011E1</code>default，如果不是跳转到跳转表。</p><p><strong><img src="C:\Users\Carzy\AppData\Roaming\Typora\typora-user-images\image-20220429143109150.png" alt="image-20220429143109150"></strong></p><p>跳转表</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291436622.png" alt="image-20220429143603427"></p><h4 id="4、这个函数能够做什么？"><a href="#4、这个函数能够做什么？" class="headerlink" title="4、这个函数能够做什么？"></a>4、这个函数能够做什么？</h4><p>​下面我们分析这个跳转表，下面分别当第五个字符为a、b、c、d、e时进行的操作</p><p>loc_40115A(a)：<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createdirectorya">CreateDirectoryA</a>创建<code>C:\\Temp</code>目录</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291438043.png" alt="image-20220429143853093"></p><p>loc_40116C(b)：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilea">CopyFileA</a>将Lab06-03.exe(argv[0])复制到<code>C:\\Temp\\cc.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291446836.png" alt="image-20220429144631847"></p><p>loc_40117F(c)：<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea">DeleteFileA</a>,删除<code>C:\\Temp\\cc.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291448411.png" alt="image-20220429144821567"></p><p>loc_40118C(d)：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyExA</a>打开注册表<code>Software\Microsoft\Windows\CurrentVersion\Run</code>，<a href="https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa">RegSetValueExA</a>设置注册表的Malware的值为<code>C:\\Temp\\cc.exe</code>。即设置自启动</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291453835.png" alt="image-20220429145315674"></p><p>loc_4011D4(e)：睡眠100秒</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291455858.png" alt="image-20220429145512732"></p><p>loc_4011E1(default)：打印<code>Error 3.2: Not a valid command provide</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291459861.png" alt="image-20220429145907048"></p><h4 id="5、在这个恶意代码中有什么本地特征码？"><a href="#5、在这个恶意代码中有什么本地特征码？" class="headerlink" title="5、在这个恶意代码中有什么本地特征码？"></a>5、在这个恶意代码中有什么本地特征码？</h4><p>​本地恶意特征码是存在注册表<code>Software\Microsoft\Windows\CurrentVersion\Run</code>中<code>Malware</code>的值为<code>C:\\Temp\\cc.exe</code></p><h4 id="6、这个恶意代码的目的是什么？-1"><a href="#6、这个恶意代码的目的是什么？-1" class="headerlink" title="6、这个恶意代码的目的是什么？"></a>6、这个恶意代码的目的是什么？</h4><p>​检测能否出网，然后去请求指定的url，然后获取该url中html注释后的第一个字符（即第五个字符），然后根据该字符决定执行指定的内容</p><h2 id="Lab-6-4"><a href="#Lab-6-4" class="headerlink" title="Lab 6-4"></a>Lab 6-4</h2><p>​在这个实验中，我们会分析在文件Lab06-04.exe中发现的恶意代码。</p><h4 id="基础静态分析-3"><a href="#基础静态分析-3" class="headerlink" title="基础静态分析"></a>基础静态分析</h4><h5 id="导入表-3"><a href="#导入表-3" class="headerlink" title="导入表"></a>导入表</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291505371.png" alt="image-20220429150555577"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291506146.png" alt="image-20220429150612992"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291506890.png" alt="image-20220429150628757"></p><h5 id="整体调用-2"><a href="#整体调用-2" class="headerlink" title="整体调用"></a>整体调用</h5><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291506187.png" alt="image-20220429150646294"></p><h4 id="1、在实验6-3和6-4的-main-函数中调用之间的区别是什么？"><a href="#1、在实验6-3和6-4的-main-函数中调用之间的区别是什么？" class="headerlink" title="1、在实验6-3和6-4的 main 函数中调用之间的区别是什么？"></a>1、在实验6-3和6-4的 main 函数中调用之间的区别是什么？</h4><p>sub_401000是检测主机是否出网，sub_4012B5是print函数，sub_401040是解析html函数，sub_401150是switch语句</p><h4 id="2、什么新的代码结构已被添加到-main-中？"><a href="#2、什么新的代码结构已被添加到-main-中？" class="headerlink" title="2、什么新的代码结构已被添加到 main 中？"></a>2、什么新的代码结构已被添加到 main 中？</h4><p>循环语句被添加到main中</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291515147.png" alt="image-20220429151533595"></p><h4 id="3、这个实验的解析-HTML-的函数和前面实验中的那些有什么区别？"><a href="#3、这个实验的解析-HTML-的函数和前面实验中的那些有什么区别？" class="headerlink" title="3、这个实验的解析 HTML 的函数和前面实验中的那些有什么区别？"></a>3、这个实验的解析 HTML 的函数和前面实验中的那些有什么区别？</h4><p>我们查看<code>sub_401040</code>，ua那里使用了格式化参数，而参数是<code>arg_0</code>,即压栈的最后一个参数</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291522610.png" alt="image-20220429152246162"></p><p>arg_0：是var_C，接下来我们跟踪var_C</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291523369.png" alt="image-20220429152324815"></p><p>Var_C：刚开始为0，var_C如果大于或等于0x5A0，则终止循环，接下来我们查看循环结构</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291524435.png" alt="image-20220429152434789"></p><p>循环结构：每次循环都会sleep一分钟，然后var_C+1，所以var_C可以作为程序运行时间。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204291530161.png" alt="image-20220429153020417"></p><p>所以lab06-04.exe与之前的exe相比，会使用ua来确定程序运行时间。</p><h4 id="4、这个程序会运行多久？（假设它已经连接到互联网）"><a href="#4、这个程序会运行多久？（假设它已经连接到互联网）" class="headerlink" title="4、这个程序会运行多久？（假设它已经连接到互联网）"></a>4、这个程序会运行多久？（假设它已经连接到互联网）</h4><p>因为中断循环的条件是var_C大于等于0x5A0(1440)，即最大会运行1440分钟(24小时)。</p><h4 id="5、在这个恶意代码中有什么新的基于网络的迹象码？"><a href="#5、在这个恶意代码中有什么新的基于网络的迹象码？" class="headerlink" title="5、在这个恶意代码中有什么新的基于网络的迹象码？"></a>5、在这个恶意代码中有什么新的基于网络的迹象码？</h4><p>请求网页时的User Agent: Internet Explorer 7.5&#x2F;pma+运行时间(分钟)</p><h4 id="6、这个恶意代码的目的是什么？-2"><a href="#6、这个恶意代码的目的是什么？-2" class="headerlink" title="6、这个恶意代码的目的是什么？"></a>6、这个恶意代码的目的是什么？</h4><p>首先该程序会检测当前主机是否出网，不出网则停止运行。然后解析指定html网页的第五个字符，将其作为命令来控制程序接下来的行为：创建文件夹<code>C:\Temp</code>、将自身复制并移动到指定目录<code>C:\Temp\cc.exe</code>、删除<code>C:\Temp\cc.exe</code>、创建自启动、睡眠100秒。该程序最大运行时间为24小时</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码分析实战-day3(x86汇编学习)</title>
    <link href="/2022/04/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day3(x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0)/"/>
    <url>/2022/04/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day3(x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0)/</url>
    
    <content type="html"><![CDATA[<p>学习《恶意代码分析实战》一书时，跟随书本所做的练习</p><h2 id="X86体系结构"><a href="#X86体系结构" class="headerlink" title="X86体系结构"></a>X86体系结构</h2><p>​大部分现代计算机体系结构在内部实现上遵循冯●诺依曼结构，这种结构包含3中硬件组件：</p><ul><li>中央处理器(CPU)，负责执行代码</li><li>内存(RAM)，负责存储有的数据和代码</li><li>输入&#x2F;输出系统(I&#x2F;O)，为硬件、键盘、显示器等设备提供接口</li></ul><p>CPU又包含一些组件。其中：</p><p>​控制单元（conteol unit）使用某一个又称为指针（instruction pointer）的寄存器（register）从内存取得要执行的指令，这个寄存器中存有指令的地址。</p><p>​寄存器是CPU中数据的基本存储单元，通过它，很多时候CPU不再需要访问内存，从而节省了时间。</p><p>​算数逻辑单元（arithmetic logic unit,ALU）执行从内存取出来的指令，并将结果放到寄存器或内存中。一条条取指令、执行指令的过程不断重复，就形成了程序的运行。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211407748.png" alt="image-20220421140746828"></p><h3 id="1、内存"><a href="#1、内存" class="headerlink" title="1、内存"></a>1、内存</h3><p>​一个程序的内存可以分为以下四个主要的节</p><ul><li><strong>数据</strong>：这个词指的是内存中一个特定的节，名为数据节（data section），其中包含了一些值。这些值在程序初始加载时被放到这里，称为静态值（static value），因为程序运行时，它们可能并不发生拜年话，还可以称为全局值（global value），因为程序的任何部分都可以使用它们。</li><li><strong>代码</strong>：代码节包括了在执行程序任务时CPU所取得的指令。这些代码决定了程序是做什么的，以及程序中的任务如何协调工作。</li><li><strong>堆</strong>：堆是为程序执行期间需要的动态内存准备的，用于创建（分配）新的值，以及消除(释放)不再需要的值。将其称为动态内存（dynamic memory），是因为其内容再程序运行期间经常被改变。</li><li><strong>栈</strong>：栈用于函数的局部变量和参数，以及控制程序执行流。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211409738.png" alt="image-20220421140930580"></p><h3 id="2、指令"><a href="#2、指令" class="headerlink" title="2、指令"></a>2、指令</h3><p>​指令是汇编程序的构成块。在x86汇编语言中，一条指令由一个助记符，以及零个或多个操作数组成，如下表：</p><p>助记符表示要执行的指令，如<code>MOV</code>表示移动数据。操作数用于说明指令要使用的信息，如寄存器或数据</p><table><thead><tr><th>助记符</th><th>目标操作数</th><th>源操作数</th></tr></thead><tbody><tr><td>mov</td><td>ecx</td><td>0x42</td></tr></tbody></table><h3 id="3、操作码和字节序"><a href="#3、操作码和字节序" class="headerlink" title="3、操作码和字节序"></a>3、操作码和字节序</h3><p>​每条指令使用操作码告诉CPU程序要执行什么样的操作</p><p>反汇编器将操作码翻译为人类易读的指令，如下表：</p><p>可以看到指令<code>mov ecx, 0x42</code>的操作码是<code>B9 42 00 00 00</code>,其中，<code>0xB9</code>对应<code>mov ecx,</code>而<code>0x42000000</code>对应<code>0X42</code>这个值。</p><table><thead><tr><th>指令</th><th>mov ecx,</th><th>0x42</th></tr></thead><tbody><tr><td>操作码</td><td>B9</td><td>42 00 00 00</td></tr></tbody></table><p>用<code>0X42000000</code>表示值<code>0x42</code>，是因为x86架构使用小端字节序。数据的字节序（endianness）是指在一个大数据项中，最高位（大端，big-endian）还是最低位（小端，little-endian）被排在第一位(即排在最低的地址上)。一些恶意代码咱网络通信时必须改变字节序，因为网络数据使用大端字节序，而x86程序使用小端字节序。因此,在（网络的）大端字节序下，IP地址<code>127.0.0.1</code>会被表示为<code>0x7F000001</code>，而在（本地内存中）小端字节序下，表示为<code>0x0100007F</code></p><h3 id="4、操作数"><a href="#4、操作数" class="headerlink" title="4、操作数"></a>4、操作数</h3><p>​操作数说明指令要使用大数据。有以下三种类型：</p><ul><li>立即数（immediate）操作数是一个固定的值，如上方的<code>0x42</code></li><li>寄存器（register）操作数指向寄存器，如上方的<code>exc</code></li><li>内存地址(memory address)操作数指向感兴趣的值所在的内存地址，一般由方括号内包含值、寄存器或方程式组成，如<code>[eax]</code></li></ul><h3 id="5、寄存器"><a href="#5、寄存器" class="headerlink" title="5、寄存器"></a>5、寄存器</h3><p>​寄存器是可以被CPU使用的少量数据存储器，访问其中内容的的速度回避访问其他存储器要块。x86处理器中有一组寄存器，可以用于临时存储或作为工作区。下面列举了最常用的x86寄存器，可以将它们归为以下四类：</p><ul><li>通用寄存器，CPU在指向期间使用。</li><li>段寄存器，用于定位内存节。</li><li>状态标志，用于做出决定。</li><li>指令指针，用于定位要指向的下一条指令。</li></ul><table><thead><tr><th>通用寄存器</th><th>段寄存器</th><th>标志寄存器</th><th>指令指针</th></tr></thead><tbody><tr><td>EAX(AX,AH,AL)</td><td>CS</td><td>EFLAGS</td><td>EIP</td></tr><tr><td>EBX(BX,BH,BL)</td><td>SS</td><td></td><td></td></tr><tr><td>ECX(CX,CH,CL)</td><td>DS</td><td></td><td></td></tr><tr><td>EDX(DX,DH,DL)</td><td>ES</td><td></td><td></td></tr><tr><td>EBP(BP)</td><td></td><td></td><td></td></tr><tr><td>ESP(SP)</td><td></td><td></td><td></td></tr><tr><td>ESI(SI)</td><td></td><td></td><td></td></tr></tbody></table><p><strong>具体介绍这些寄存器的分类</strong></p><p>​所有通用寄存器的大小都是32位，可以在汇编代码中以32位或16位引用。比如<code>EDX</code>指向这个完整的32位寄存器，而<code>DX</code>指向<code>EDX</code>寄存器中的低16位。</p><p>​有四个寄存器（EAX,EBX,ECX,EDX）还剋以8位值的方式引用，从而是哟其最低的8位，或次低的8位，例如，<code>AL</code>指向<code>EAX</code>寄存器的最低8位，而<code>AH</code>指向它的次低8位。</p><p>上表列出了堆这些通用寄存器的所有可能引用方式，<code>EAX</code>寄存器的分解方法见下图，其中32位（4字节）寄存器<code>EAX</code>存储了值<code>0XA9DC81F5</code>，代码可以使用其他三种方法来引用<code>EAX</code>中的这个数据：<code>AX</code>（2字节）是<code>0x81F5</code>,<code>AL</code>（1字节）是<code>0xF5</code>,<code>AH</code>（1字节）是<code>0x81</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211458810.png" alt="image-20220421145837606"></p><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>​通用寄存器一般用于存储数据或内存地址，而且经常交换这使用以完成的程序，不过，虽然它们被称为通用寄存器，但它们并不完全通用。</p><p>​一些x86指令只能使用特定的寄存器。例如，乘法和除法指令就只能使用<code>EAX</code>和<code>EDX</code>。</p><p>​除了指令的定义，通用寄存器还被程序的一致特性使用。在编译代码时对寄存器的一致特性称为约定（convention）。具备编译器使用约定的知识可以让恶意代码分析师更快地阅读代码，因为不需要浪费时间去搞清除一些寄存器是如何被使用的。比如，<code>EAX</code>通常存储了一个函数调用的返回值，因此，如果你看到在一个函数调用之后马上用到了<code>EAX</code>寄存器，可能就是在操作返回值了。</p><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>​<code>EFLAGS</code>寄存器是一个标志寄存器。在x86架构中，它是32位的，每一位是一个标志。在执行期间，每一位表示要么是置位（值为1），要么是清除（值为0），并由这些值来控制CPU的运算，或者给出某些CPU运算的值。对恶意代码分析来说，最重要的一些标志介绍如下：</p><ul><li><strong>ZF</strong>：当一个运算的结果等于0时，<code>ZF</code>被置位，否则被清除。</li><li>**<code>CF</code>**：当一个运算的结果相对于目标操作数太大或太小时，<code>CF</code>被置位，否则被清除。</li><li>**<code>SF</code>**：当一个运算的结果为负数，<code>SF</code>被置位；若结果为正数，<code>SF</code>被清除。对算数运算，当运算结果的最高位值为1时，<code>SF</code>也会被置位。</li><li>**<code>TF</code>**：<code>TF</code>用于调试，当它被置位时，x86处理器每次只执行一条指令。</li></ul><h4 id="EIP，指令指针"><a href="#EIP，指令指针" class="headerlink" title="EIP，指令指针"></a>EIP，指令指针</h4><p>​在x86架构中，<code>EIP</code>寄存器，又称为指令指针或程序计数器，保存了程序将要执行的下一条指令在内存的地址中。<code>EIP</code>的唯一作用就是告诉处理器接下来要做说明。</p><blockquote><p><strong>注意</strong>：当EIP被破坏（即指向了一个不包含合法程序代码的内存地址）时，CPU无法取得一条合法指令来执行，此时正在运行的程序就可能崩溃。当你控制了EIP，也就控制了CPU将要执行什么，这也就是为什么攻击者试图通过漏洞利用获取对EIP的控制。通常攻击者先要使攻击代码进入内存，然后改变EIP使其指向那段代码，从而攻击系统。</p></blockquote><h3 id="6、简单指令"><a href="#6、简单指令" class="headerlink" title="6、简单指令"></a>6、简单指令</h3><table><thead><tr><th>指令</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>mov</td><td>用于将数据从一个位置移动到另一个位置</td><td>mov destination,source</td></tr><tr><td>lea</td><td>将一个内存地址付给目的操作数。</td><td>lea destination,source</td></tr><tr><td>add</td><td>从目标操作数中加上一个值</td><td>add destination,value</td></tr><tr><td>sub</td><td>从目标操作数中减去一个值</td><td>sub destination,value</td></tr><tr><td>inc</td><td>将一个寄存器加一</td><td>inc value</td></tr><tr><td>dec</td><td>将一个寄存器减一</td><td>dec value</td></tr><tr><td>mul</td><td>eax乘以指定的值</td><td>mul value</td></tr><tr><td>div</td><td>eax除以指定的值</td><td>div value</td></tr><tr><td>or</td><td>逻辑运算符</td><td>or destination,source</td></tr><tr><td>and</td><td>逻辑运算符</td><td>and destination,source</td></tr><tr><td>xor</td><td>逻辑运算符</td><td>xor destination,source</td></tr><tr><td>shr</td><td>对寄存器进行移位操作，对目的操作数右移指定的值</td><td>shr destination,count</td></tr><tr><td>shl</td><td>对寄存器进行移位操作，对目的操作数左移指定的值</td><td>shl destination,count</td></tr><tr><td>ror</td><td>循环移位指令，对目的操作数右循环移指定的值</td><td>ror destionation,count</td></tr><tr><td>rol</td><td>循环移位指令，对目的操作数左循环移指定的值</td><td>rol destionation,count</td></tr><tr><td>nop</td><td>上面都不做。直接执行下一条指令;  实际是xchg eax,eax的一个伪名字</td><td></td></tr></tbody></table><h4 id="指令示例"><a href="#指令示例" class="headerlink" title="指令示例"></a>指令示例</h4><h5 id="mov示例"><a href="#mov示例" class="headerlink" title="mov示例"></a><strong>mov示例</strong></h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>mov eax,ebx</td><td>将EBX中的内容复制至EAX寄存器</td></tr><tr><td>mov eax,0x42</td><td>将立即数0x42复制至EAX寄存器</td></tr><tr><td>mov eax,[0x4037C4]</td><td>将内存地址0x4037C4的4个字节复制到EAX寄存器</td></tr><tr><td>mov eax,[ebx]</td><td>将EBX寄存器指向的内存地址处4个字节复制至EAX寄存器</td></tr><tr><td>mov eax,[ebx+esi*4]</td><td>将ebx+esi*4等式结果指向的内存地址处4个字节复制至EAX</td></tr></tbody></table><h5 id="lea示例"><a href="#lea示例" class="headerlink" title="lea示例"></a><strong>lea示例</strong></h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>lea eax,[ebx+8]</td><td>将EBX+8的值给EAX</td></tr><tr><td>mov eax,[ebx+8]</td><td>与上面那条指令相反，该指令加载内存中地址为EBX+8处的数据</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211637274.png" alt="image-20220421163756937"></p><p>上图左侧展示了<code>EAX</code>和<code>EBX</code>寄存器的值，在右侧展示了内存中的数据。<code>EBX</code>的值为<code>0xB30040</code>，在<code>0xB30048</code>这个内存地址保存的值为<code>0X20</code>。因此指令<code>mov eax,[ebx+8]</code>将(从内存中获取的值)<code>0x20</code>赋给<code>EAX</code>。而指令<code>lea eax,[ebx+8]</code>则将<code>0xB30048</code>这个值给<code>EAX</code></p><h5 id="sub、add、inc、dec示例"><a href="#sub、add、inc、dec示例" class="headerlink" title="sub、add、inc、dec示例"></a>sub、add、inc、dec示例</h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>sub eax,0x10</td><td>EAX寄存器值减去0x10</td></tr><tr><td>add eax,ebx</td><td>将EBX值加入EAX并将结果保存至EAX</td></tr><tr><td>inc edx</td><td>EDX值递增1</td></tr><tr><td>dec ecx</td><td>ECX值递减1</td></tr></tbody></table><p>其中<code>sub</code>指令会修改两个重要的标志:<code>ZF</code>和<code>CF</code>。如果结果为零，<code>ZF</code>被置位；如果目标操作数比减去的值小，则<code>CF</code>被置位。</p><h5 id="mul、div示例"><a href="#mul、div示例" class="headerlink" title="mul、div示例"></a>mul、div示例</h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>mul 0x50</td><td>EAX值乘以0x50，并将结果存入EDX:EAX寄存器中</td></tr><tr><td>div 0x75</td><td>将EDX:EAX值除以0x75，并将结果存入EAX，将余数存入EDX</td></tr></tbody></table><blockquote><p><strong>注意</strong>：EAX寄存器必须在乘法指令出现前就赋值号。乘法结果以64为的形式分别存储在两个寄存器中：EDX和EAX。其中EDX存储了高的32位，EAX存储低的32位。下图展示了当乘法的结果是5 000 000 000（十进制）这样大到无法用一个寄存器存储时，EDX和EAX中的值</p><p>​duv指令则与mul类似，但运算方向正好相反：他将EDX和EAX合起来存储的64位值除以value。因此在做除法之前，EDX和EAX这两个寄存器必须赋值好。除法的商将存储到EAX，余数则存储在EDX中。</p><p>​例如：使用模(modulo)运算得到除法的余数，这个运算会被编译位在div指令后去EDX寄存器的值(因为除法保留了余数)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211700114.png" alt="image-20220421170034494"></p><h5 id="常用的逻辑和移位算术运算指令"><a href="#常用的逻辑和移位算术运算指令" class="headerlink" title="常用的逻辑和移位算术运算指令"></a>常用的逻辑和移位算术运算指令</h5><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>xor eax,eax</td><td>将EAX寄存器清零</td></tr><tr><td><div style="width:100pt">or eax,0x7575</div></td><td>将EAX值进行与0x7575的or操作</td></tr><tr><td>mov eax,0xA</td><td>将0xA(1010)赋值给EAX寄存器</td></tr><tr><td>shl eax,2</td><td>将EAX寄存器左移两位，与mov eax,0xA,结合将导致EAX&#x3D;0X28，因为1010左移两位之后位101000(0x28)</td></tr><tr><td>mov bl,0xA</td><td>将0xA赋值给BL寄存器</td></tr><tr><td>ror bl,2</td><td>将BL寄存器循环移位移两位，与mov bl,0xA结合将导致BL&#x3D;10000010,因为1010向右循环移动2位为10000010</td></tr></tbody></table><h5 id="nop"><a href="#nop" class="headerlink" title="nop"></a>nop</h5><p>​nop什么事情也不做。当它出现时，直接执行下一条指令。</p><p>​这条指令的opencode是<code>0X90</code>。在缓冲区溢出攻击中，当攻击者无法完美地控制利用代码，就经常使用<code>NOP</code>滑板，它起到了填充代码的作用，以降低shellcode可能在中间部分开始执行所造成的风险</p><h3 id="7、栈"><a href="#7、栈" class="headerlink" title="7、栈"></a>7、栈</h3><p>​用于函数的内存、局部变量、流控制结构等被存储在栈中。栈是一种用压合弹操作来刻画的数据结构，向栈中压入一些东西，然后再把它们弹出来。它是一种后入先出的结构。</p><p>​x86结构有对栈的内建支持。用于这种支持的寄存器包含<code>ESP</code>和<code>EBP</code>。其中：</p><ul><li><code>ESP</code>是栈指针，包含了指向栈顶的内存地址，一些东西被压入或弹出栈时，这个寄存器的值相应改变</li><li><code>EBP</code>是栈基址寄存器，在一个函数中会保存不变，因此程序把它当作定位器，用来确定局部变量和参数的位置。</li></ul><p>​在内存中，栈被分配成自顶向下的，最高地址最先被使用。当一个值被压入栈时，使用低一点的地址</p><p>​栈只能用于短期存储，他经常用于保存局部变量、参数和返回地址。其主要用途是管理函数调用之间的数据交换</p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><table><thead><tr><th>指令</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>push</td><td>将参数压入栈中</td><td>push value</td></tr><tr><td>pop</td><td>将参数弹出栈中</td><td>pop value</td></tr><tr><td>pusha</td><td>按照顺序将16位寄存器都压入栈中：AX、CX、DX、BX、SP、BP、SI、DI</td><td>pusha</td></tr><tr><td>pushad</td><td>按照顺序将32位寄存器都压入栈中：EAX、ECX、EDX、EBX、ESP、ESI、EDI</td><td>pusha</td></tr><tr><td>call</td><td>调用指定函数</td><td>call value</td></tr><tr><td>leave</td><td>结束堆栈帧：常用于结语，使ESP等于EBP，然后从栈中弹出EBP</td><td>leave</td></tr><tr><td>enter</td><td>创建堆栈帧：</td><td>ENTER numbytes, nestinglevel</td></tr><tr><td>ret</td><td>从栈中弹出返回地址给EIP</td><td></td></tr></tbody></table><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><blockquote><p>1、使用push指令将参数压入栈中。</p><p>2、使用call memory_location来掉用函数，此时当前指令地址(指EIP寄存器中的内容)被压入栈中。这个地址会在函数结束后，被用于返回著代码。当函数开始执行时，EIP的值被设为memory_location(即函数的起始地址)。</p><p>3、通过函数的序言部分，分配栈中用于局部变量的空间，EBP(基址指针)也被压入栈中。这样就达到了为调用函数八平村EBP的目的。</p><p>4、函数开始做它的工作。</p><p>5、通过函数的结语部分，恢复栈。调整ESP来释放局部变量，恢复EBP，以使得调用函数可以准确地确定它的变量。<strong>leave</strong>指令可以用作结语，因为它的功能是使<strong>ESP</strong>等于<strong>EBP</strong>，然后从栈中弹出<strong>EBP</strong>。</p><p>6、函数通过调用<strong>ret</strong>指令返回。这个指令会从栈中弹出返回地址给<strong>EIP</strong>，因此程序会从原来调用的地方继续执行。</p><p>7、调整栈，以移除此前压入的参数，除非它们在后面还要被使用</p></blockquote><h4 id="栈的布局"><a href="#栈的布局" class="headerlink" title="栈的布局"></a>栈的布局</h4><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204231231517.png" alt="image-20220423123137072"></p><p>当数据被压入栈时，ESP会随之减小，如下图：</p><ul><li>如果执行<code>push eax</code>指令，ESP就会减少4，变成<code>0x12F028</code>，而EAX中的数据则会被赋值到<code>0x12F028</code>处。</li><li>如果执行<code>pop ebx</code>，则<code>0X12F028</code>处的数据就会被赋给EBX寄存器，而ESP也随之增加4.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204231231793.png" alt="单独的一个栈帧"></p><h3 id="8、条件指令"><a href="#8、条件指令" class="headerlink" title="8、条件指令"></a>8、条件指令</h3><table><thead><tr><th>指令</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>test</td><td>与and指令功能一样，但不会影响操作数，只设置标志位</td><td>test dst,src</td></tr><tr><td>cmp</td><td>与sub指令功能一样，但不会影响操作数,只设置标志位</td><td>cmp dst,src</td></tr></tbody></table><p><strong>示例</strong></p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>test eax,eax</td><td>将eax寄存器与eax寄存器比较，执行后需要关注ZF标志位</td></tr><tr><td>cmp eax,ebx</td><td>使用eax寄存器的值减去ebx寄存器的值，标志位变化如下图</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204231245944.png" alt="cmp 指令与标志位"></p><h3 id="9、分支指令"><a href="#9、分支指令" class="headerlink" title="9、分支指令"></a>9、分支指令</h3><table><thead><tr><th>指令</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>jmp</td><td>跳转到指定位置</td><td>jmp location</td></tr><tr><td>jz</td><td>如果ZF&#x3D;1，跳转至指定位置</td><td>jz location</td></tr><tr><td>jnz</td><td>如果ZF&#x3D;0，跳转至指定位置</td><td>jnz location</td></tr><tr><td>je</td><td>与jz类似，但通常在一条cmp指令后使用。如果源操作数与目的操作数相等，则跳转</td><td>je location</td></tr><tr><td>jne</td><td>与jnz类似，但通常在一条cmp指令后使用。如果源操作数与目的操作数不相等，则跳转</td><td>jne location</td></tr><tr><td>jg</td><td>在一条cmp指令做有符号比较之后，如果目的操作数大于源操作数，跳转</td><td>jg location</td></tr><tr><td>jge</td><td>在一条cmp指令做有符号比较之后，如果目的操作数大于或等于源操作数，跳转</td><td>jge location</td></tr><tr><td>ja</td><td>与jg类似，但使用无符号比较</td><td>ja location</td></tr><tr><td>jae</td><td>与jge类似，但使用无符号比较</td><td>jae location</td></tr><tr><td>jl</td><td>在一条cmp指令做有符号比较之后，如果目的操作数小于源操作数，则跳转</td><td>jl location</td></tr><tr><td>jle</td><td>在一条cmp指令做有符号比较之后，如果目的操作数小于或等于源操作数，则跳转</td><td>jle location</td></tr><tr><td>jb</td><td>与jl类似，但使用无符号比较</td><td>jb location</td></tr><tr><td>jbe</td><td>与jle类似，但使用无符号比较</td><td>jbe location</td></tr><tr><td>jo</td><td>如果前一条指令置位了溢出标志位(OF&#x3D;1),则跳转</td><td>jo location</td></tr><tr><td>js</td><td>如果符号标志位被置位(SF&#x3D;1),则跳转</td><td>js location</td></tr><tr><td>jecxz</td><td>如果ECX&#x3D;0,则跳转</td><td>jecxz location</td></tr></tbody></table><h3 id="10、重复指令"><a href="#10、重复指令" class="headerlink" title="10、重复指令"></a>10、重复指令</h3><p>​重复指令是一组操作数据缓冲区的指令。数据缓冲区通常是一个字节数组的形成，也可以是单字或双字。</p><p>​在重复指令操作中，使用<code>ESI</code>和<code>EDI</code>寄存器，<code>ESI</code>是源索引寄存器，<code>EDI</code>是目的索引寄存器。还有<code>ECX</code>用作计数器的变量</p><p>​重复指令还需要一个前缀，用于对长度超过1的数据做操作</p><p>下边中的x可以是b、w、d，分别表示为字节、字、双字。</p><table><thead><tr><th>指令</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>movsx</td><td></td><td></td></tr><tr><td>cmpsx</td><td></td><td></td></tr><tr><td>stosx</td><td></td><td></td></tr><tr><td>scasx</td><td></td><td></td></tr><tr><td>rep</td><td>终止指令</td><td></td></tr></tbody></table><h4 id="rep指令终止条件"><a href="#rep指令终止条件" class="headerlink" title="rep指令终止条件"></a>rep指令终止条件</h4><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>rep</td><td>循环终止条件 ECX&#x3D;0</td></tr><tr><td>repe,repz</td><td>循环终止条件ECX&#x3D;0 or ZF&#x3D;0</td></tr><tr><td>reone,repnz</td><td>循环终止条件ECX&#x3D;0 or ZF&#x3D;1</td></tr></tbody></table><p>​在x86下，使用重复前缀来做多字节操作。<strong>rep</strong>指令会增加<strong>ESI</strong>和<strong>EDI</strong>这两个偏移，减少<strong>ECX</strong>寄存器，rep亲嘴会不断重复，直至<code>ECX=0</code>。<strong>repe&#x2F;repz</strong>和<strong>repne&#x2F;repnz</strong>前缀则不断重复，直至<code>ECX=0</code>或直至<code>ZF=1或0</code>。</p><p>​因此，在大部分数据缓冲区操作指令中，<strong>ESI、EDI</strong>和<strong>ECX</strong>必须为<strong>rep</strong>指令的生效，而进行适当的初始化。</p><h4 id="重复指令详解"><a href="#重复指令详解" class="headerlink" title="重复指令详解"></a>重复指令详解</h4><ul><li>movsb：将一串字符串从一个位置移动到另一个位置。rep前缀通常与movsb一起使用，从而复制一串长度有ECX决定的字节。movsb指令从ESI指向地址取出一个字节，将其存入EDI指向地址，然后根据方向标志(DF)的设置，将ESI和EDI的值加1或者减1.如果DF&#x3D;0，则加，否则减。</li><li>cmpsb：比较两串字节，以确定其是否是相同的数据，cmpsb指令用ESI指向地址的字节减去EDI指向地址的字节，并更新相关的标志位，它经常与repe前缀一起使用。此时，<strong>cmpsb</strong>指令逐一比较两串字节，直至发现一处不同，或比较到肉。<strong>empsb</strong>指令从地址ESI获得一个字节，将其与EDI指向位置的字节进行比较，并设置标志位，然后对ESI和EDI分别加1.如果有<strong>repe</strong>前缀，就检查ECX的值和标志位，如果ECX&#x3D;0或者ZF&#x3D;0，就停止重复。</li><li>scasb：从一串字节中搜索一个值。这个值有AL寄存器给出。它的工作方式与<strong>cmpsb</strong>一样，但是它是将ESI指向地址的字节与AL进行比较，而不是与EDI指向地址的字节比较。<strong>repe</strong>操作会使得这个比较不断继续，直到找到该字节，或者ECX&#x3D;0.如果在这串字节中找到了那个值，则其位置会被存储在ESI中。</li><li>stosb：将值存储到EDI指向的地址。它与scasb一样，但不去搜索，而是将指定的字节存入EDI指向的地址。rep前缀与scasb一起使用后，就初始化了一段内存缓冲区，其中的每个字节都是相同的值</li></ul><h4 id="rep指令示例"><a href="#rep指令示例" class="headerlink" title="rep指令示例"></a>rep指令示例</h4><table><thead><tr><th align="left">指令</th><th>描述</th></tr></thead><tbody><tr><td align="left"><div style="width:100pt">repe cmpsb</div></td><td>用于比较两块数据缓冲区。EDI和ESI必须被设为两段缓冲区的地址，ECX必须被设为缓冲区长度。当ECX&#x3D;0或者发现缓冲区不一致的时候，停止比较</td></tr><tr><td align="left">rep stosb</td><td>用于用一个给定的值初始化一块缓冲区中所有字节。EDI包含了缓冲区地址，AL则包含初始值。这个指令通常与<code>xor eax,eax</code>一起使用</td></tr><tr><td align="left">rep movsb</td><td>一般用于复制缓冲区中的字节。ESI需要被设为源缓冲区地址，EDI被设为目的缓冲区地址，ECX则必须为要复制的长度。会逐字节复制，直至ECX&#x3D;0</td></tr><tr><td align="left">repne scasb</td><td>用于在一段数据缓冲区中搜索一个字节。EDI需指向缓冲区地址，AL则包含要找的字节，ECX设为缓冲区长度。当ECX&#x3D;0或找到该字节时，比较停止</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码分析实战-day2(基础动态分析)</title>
    <link href="/2022/04/21/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day2(%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90)/"/>
    <url>/2022/04/21/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day2(%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90)/</url>
    
    <content type="html"><![CDATA[<p>学习《恶意代码分析实战》一书时，跟随书本所做的练习。</p><h2 id="Lab-3-1"><a href="#Lab-3-1" class="headerlink" title="Lab 3-1"></a>Lab 3-1</h2><p>使用动态分析基础技术来分析在Lab03-01.exe文件中的恶意代码</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1、找出这个恶意到吗的导入函数与字符串列表</p><p>2、这个恶意代码在主机上的感染迹象特征是什么</p><p>3、这个恶意代码是否存在一些有用的网络特征码？如果存在，它们是什么</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><h4 id="1、导入函数与字符串"><a href="#1、导入函数与字符串" class="headerlink" title="1、导入函数与字符串"></a>1、导入函数与字符串</h4><p>导入函数：<code>kernel32.dll</code>中的<code>ExitProcess</code>：结束调用的进程及其他所有的线程</p><p>字符串列表：存在一个网址，以及<code>Software\ Microsoft\Active Setup\Installed Components\</code>注册表，该注册表在恶意软件中常用于开机自启(ActiveX方式启动)：该方式自启动会在该注册表下注册一条子建，任何在子建中新建<code>StubPath</code>的值项，内容为启动的文件名，</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201443103.png" alt="image-20220420144325586"></p><p>查看启动时导入的DLL列表，使用了<code>ws2_32.dll</code>由此可以确定该木马具备联网功能</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201527397.png" alt="image-20220420152746617"></p><h4 id="2、恶意代码的感染特征"><a href="#2、恶意代码的感染特征" class="headerlink" title="2、恶意代码的感染特征"></a>2、恶意代码的感染特征</h4><p>使用process Monitor 设置过滤规则</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201609213.png" alt="image-20220420160913663"></p><p>然后就会看到该exe写入了一个文件，且大小为7168</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201610514.png" alt="image-20220420161019536"></p><p>设置自启动</p><p><code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\</code> 中设置<code>VideoDriver</code>的值为<code>C:\WINDOWS\system32\vmx32to64.exe</code>，</p><p>每次开机都会运行该文件</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201619117.png" alt="image-20220420161954713"></p><p>Lab03-01.exe和vmx32to64.exe两个文件的hash值一样，说明中病毒后该病毒会将自身复制一份到<code>C:\WINDOWS\system32\vmx32to64.exe</code></p><h4 id="3、网络特征"><a href="#3、网络特征" class="headerlink" title="3、网络特征"></a>3、网络特征</h4><p>由搜索字符串和导入函数可得知，该病毒会访问<code>www.practicalmalwareanalysis.com</code></p><h2 id="Lab-3-2"><a href="#Lab-3-2" class="headerlink" title="Lab 3-2"></a>Lab 3-2</h2><p>使用动态分析基础技术来分析在Lab03-02.dll文件中发现的恶意代码</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>1、你怎样才能让这个恶意代码自行安装</p><p>2、在安装之后，你如何让这个恶意代码运行起来？</p><p>3、你怎么能找到这个恶意代码是在哪个进程下运行的？</p><p>4、你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码信息?</p><p>5、这个恶意代码在主机上的感染迹象特征是什么？</p><p>6、这个恶意代码是否存在一些有用的网络特征码？</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>存在<code>install、Uninstall、ServiceMain、UninstallService、installA</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201812472.png" alt="image-20220420181226100"></p><p>查看输入表</p><p>KERNEL32.dll</p><blockquote><p> CreateProcess</p></blockquote><p>ADVAPI32.dll</p><blockquote><p>RegSetValueEx</p></blockquote><p>WININER.dll</p><blockquote><p>HttpSendRequest</p></blockquote><p>WS2_32.DLL</p><p>截图：</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201834703.png" alt="image-20220420183454043"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201835725.png" alt="image-20220420183539621"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201836012.png" alt="image-20220420183555445"></p><h5 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h5><p>得到一个网址，以及<code>serve.html</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201844432.png" alt="image-20220420184429944"></p><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p>安装恶意代码(安装前先使用Regshot拍摄注册表快照)</p><blockquote><p>rundll32.exe Lab03-02.dll,installA  &#x2F;&#x2F;直接在dll目录下运行即可</p></blockquote><p>安装完成后拍摄快照2，然后进行对比</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201900309.png" alt="image-20220420190053164"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201903429.png" alt="image-20220420190315142"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201903524.png" alt="image-20220420190334603"></p><p>由于上方的是16进制值，我看不懂，所以我就去查注册表</p><blockquote><p>imagePath:  svchost.exe -k netsvcs  &#x2F;&#x2F;启动了netsvcs服务，这说明这是一款典型的利用Svchost进程加载运行的木马</p><p>且DisplayName和DependOnService都被设定为特定的值</p></blockquote><p><code>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\IPRIP</code>和另一个注册表下的内容都是一样的</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201905028.png" alt="image-20220420190546724"></p><p>[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\TermService] 下记录着“系统服务”的相关设置。那么ControlSet001、ControlSet002、ControlSet有什么区别呢？</p><blockquote><p> ControlSet001：系统真实的配置信息。</p><p> CurrentControlSet：运行时配置。 windows启动时会从ControlSet001复制一份副 本，作为操作系统当前的配置信息。我们对于计算机配置所作的修改都是直接写入到 CurrentControlSet，在重启过程中，windows会用CurrentControlSet的内容覆盖掉ControlSet001，以 保证这两个控件组一致。</p><p> ControlSet002：“最近一次成功启动的配置信息”。 当操作系统每成功启动一次（指成功登录），它都将CurrentControlSet和ControlSet001中的数据复制到ControlSet002中。</p></blockquote><h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p>根据注册表得知安装dll后，会安装IPRIP服务，所以我们直接启动该服务即可启动该恶意代码</p><blockquote><p>net start IPRIP</p></blockquote><h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><p>由于之前我们知道了是用<code>svchost.exe</code>启动的该服务，我们可以指向查看该服务的DLL即可看到<code>lab03-02.dll</code>被引用</p><p>或者我们可以直接在Process Exploisrer中搜<code>Lab03-02.dll</code>，也可以得知是<code>svchost.exe</code>引用了该DLL</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201934829.png" alt="image-20220420193443403"></p><h4 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h4><p>根据其会在注册表上设置<code>DisplayName</code>为特定的值，所以在感染的主机上查看svchost.exe的服务名称是否有<code>Intranet Network Awareness</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204201952500.png" alt="image-20220420195239388"></p><h4 id="6、网络特征"><a href="#6、网络特征" class="headerlink" title="6、网络特征"></a>6、网络特征</h4><p>192.168.163.135</p><blockquote><p>nc -l -p 80  &#x2F;&#x2F;监听80端口</p></blockquote><p>修改host文件</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204202005185.png" alt="image-20220420200510749"></p><p>然后就会在192.168.163.135主机上监听到一条请求<code>serve.html</code>的信息</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204202003252.png"></p><p>所以查看感染主机是否有访问<code>practicalmalwareanalysis.com/serve.html</code>即可</p><h2 id="Lab-3-3"><a href="#Lab-3-3" class="headerlink" title="Lab 3-3"></a>Lab 3-3</h2><p>在一个安全的环境中执行Lab03-03.exe文件中发现的恶意代码，同时使用基础的动态分析工具监视它的行为</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>1、当你使用Process Explorer工具进行监视时，你注意到了什么？</p><p>2、你可以找出任何的内存修改行为码？</p><p>3、这个恶意代码在主机上的感染迹象特征是什么？</p><p>4、这个恶意代码的目的是什么？</p><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><h4 id="1、-1"><a href="#1、-1" class="headerlink" title="1、"></a>1、</h4><p>打开Process Explorer以及Process Monitor，然后运行Lab03-03.exe</p><p><strong>Process Expolorer</strong></p><p>可以看到创建了一个PID为<code>1748</code>的<code>svchost.exe</code>进程，然后退出</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211035276.png" alt="image-20220421103520467"></p><p>我们可以看到<code>Lab03-03.exe</code>退出后，PID<code>1748</code>的进程还在以“孤儿”进程方式运行，我们可以看到下图的粉红色的<code>svchost.exe</code>与PID<code>1748</code>的<code>svchost.exe</code>有很明显的区别，正常的<code>svchost.exe</code>通常是作为<code>services.exe</code>的子进程，所以PID为<code>1748</code>的<code>svhost.exe</code>进程很可疑。</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211037466.png" alt="image-20220421103713275"></p><h4 id="2、-1"><a href="#2、-1" class="headerlink" title="2、"></a>2、</h4><p>我们对比正常的<code>svchost.exe</code>进程与PID<code>1748</code>的<code>svchost.exe</code>进程之间的磁盘镜像和内存镜像中字符串列表来寻找不同点</p><p><strong>磁盘镜像字符串</strong></p><p>磁盘进行字符串相同</p><p>左边为正常进程，右边为异常进程</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211055025.png" alt="image-20220421105504805"></p><p><strong>内存镜像字符串</strong></p><p>可以看到有非常明显的不同</p><p>左边为正常进程，右边为异常进程</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211056330.png" alt="image-20220421105643812"></p><h4 id="3、-1"><a href="#3、-1" class="headerlink" title="3、"></a>3、</h4><p>由于我们在运行<code>Lab03-03.exe</code>之前就开启了<code>Process Monitor</code>，我们直接过滤PID<code>1748</code>的进程，看它在运行时干了什么</p><p>过滤规则</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211100905.png" alt="image-20220421110049675"></p><p>创建了<code>practicalmalwareanalysis.log</code>并往里面写入内容</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211101536.png" alt="image-20220421110129320"></p><p>所以这个木马的感染迹象特征是会在木马运行目录创建一个<code>practicalmalwareanalysis.log</code>文件，感染主机会单独运行一个<code>svchost.exe</code>进程，在进程的内存镜像中存在一个<code>practicalmalwareanalysis.log</code>的字符串</p><h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><p>我们在<code>Process Monitor</code>看到该进程创建了一个log文件，并往里面写入了内容，我们去查看该文件</p><p>log文件内容</p><p>1748是我们刚刚设置过滤规则时使用键盘输入的PID号，所以这程序可能是一个击键记录器</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211105537.png" alt="image-20220421110515073"></p><p>为了验证我们的猜想，我们创建一个文件，并往里面输入内容</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211108236.png" alt="image-20220421110802281"></p><p>再次查看log文件，可以看到这是一个击键记录器，将我们通过键盘输入的内容记录到log文件中</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204211109321.png" alt="image-20220421110902819"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码分析实战-day1(基础静态分析)</title>
    <link href="/2022/04/19/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day1(%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90)/"/>
    <url>/2022/04/19/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-day1(%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90)/</url>
    
    <content type="html"><![CDATA[<p>学习《恶意代码分析实战》一书时，跟随书本所做的练习。</p><h1 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h1><p><a href="https://codeload.github.com/Hadreysl/-/zip/refs/heads/master">下载连接</a></p><h2 id="Lab-1-1"><a href="#Lab-1-1" class="headerlink" title="Lab 1-1"></a>Lab 1-1</h2><p>分析Lab01-01.exe和Lab01-01.dll</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1、将代码上传至http[:]&#x2F;&#x2F;www[.]VirusTotal[.]com&#x2F;进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗</p><p>2、这些文件是什么时候编译的</p><p>3、这两个文件中是否存在迹象说明它们是否被加壳或混淆了？如果是，这些迹象在哪里</p><p>4、是否有导入函数显示出了这个恶意代码是做说明的？如果是，是哪些导入函数？</p><p>5、是否有导入函数显示或基于主机的迹象，让你可以在受感染系统上查找？</p><p>6、是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码？</p><p>7、你猜这些文件的目的是什么</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>1、</p><p>lab01-01.exe</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191343955.png" alt="image-20220419134310648"></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191345676.png" alt="image-20220419134536322"></p><p>lab01-01.dll</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191347625.png" alt="image-20220419134726304"></p><p>2、编译时间：2010-12-20 0：16：19</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191349022.png" alt="image-20220419134951503"></p><p>3、加壳情况：否。每个节的虚拟大小和实际大小都差不多</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191351037.png" alt="image-20220419135148037"></p><p>4、释放一个文件</p><p><strong>EXE</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191357974.png" alt="image-20220419135744882"></p><p>通过<code>createFile</code>创建一个新文件，并用<code>FindNextFile/FindFirstFile</code>查找该文件,还使用了<code>CopyfileA</code>复制文件，使用该病毒会查找和释放文件、以及复制文件</p><p>然后用<code>CreateFileMapping</code>加载该文件，使用<code>MapViewOfFile</code>将来读取和修改该文件，该函数可以修改PE文件，</p><p><strong>DLL</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191414606.png" alt="image-20220419141409485"></p><p>存在<code>Sleep</code>延时执行，以及<code>CreateProcess</code>创建并启动一个新进程，即会执行文件，结合前面的exe分析可得知，该木马会释放一个pe文件，并执行，</p><p>该DLL导如了<code>WS2_32.dll</code>即存在联网行为</p><p>5、exe中存在路径<code>c:\\windows\\system32\\kerne132.dll</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191431960.png" alt="image-20220419143100626"></p><p>跟进去发现是创建一个文件，至此，可以得知，该木马会<code>c:\\windows\\system32\\kerne132.dll</code>，只需要查找该文件即可定位</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191430505.png" alt="image-20220419143036570"></p><p>6、DLL中存在127[.]26[.]152[.]13这个IP，只要在受感染的机器上查看是否有访问这个IP即可找到该恶意代码</p><p>7、</p><h2 id="Lab-1-2"><a href="#Lab-1-2" class="headerlink" title="Lab 1-2"></a>Lab 1-2</h2><p>分析Lab01-02.exe</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>1、将代码上传至http[:]&#x2F;&#x2F;www[.]VirusTotal[.com]&#x2F;进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？</p><p>2、是否由这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳，如果可能的话。</p><p>3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？</p><p>4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码所感染的机器？</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><p>1、</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191437155.png" alt="image-20220419143732139"></p><p>2、存在加壳、UPX壳，虚拟大小和实际大小不符合</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191438115.png" alt="image-20220419143834632"></p><p>使用UPX脱壳 <code>upx.exe -d lab01-02.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191517292.png" alt="image-20220419151721265"></p><p>3、导入了<code>Kernel32.dll、ADVAAPI32.DLL、WINNET.DLL</code></p><p><code>WINNET.DLL</code>中使用了<code>InternetOpenUrl</code>这说明使用了FTP、HTTP或HTTPS访问了特定url</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191555933.png" alt="image-20220419155508706"></p><p><code>Kernel32.dll</code>中使用了<code>GetModuleFileName</code>在运行进程时进行修改和复制文件，以及使用<code>CreateMutexA</code>和<code>OpenMutex</code>来创建一个互斥对象，以及打开互斥对象，使该主机只存在一个该对象。以及使用<code>CreateWaitableTimer</code>和<code>SetWaitableTimer</code>创建定时任务，</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191555981.png" alt="image-20220419155523809"></p><p><code>ADVAPI32.dll</code>中使用了<code>CreateServiceA</code>来创建一个在启动时刻运行的服务，常用于持久化、隐藏或启动内核驱动</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191555911.png" alt="image-20220419155537446"></p><p>4、查找字符串时可以得知，该exe会访问<code>http[:]//www[.]malwareanalysisbook[.]com</code></p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191600971.png" alt="image-20220419160053840"></p><p>跟进该字符串</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191601665.png" alt="image-20220419160126963"></p><p>继续跟进该变量</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191602079.png" alt="image-20220419160159556"></p><p>使用了<code>InternetOpen</code>初始化访问的URL，可以确认感染的机器会访问该URL，这是我们清除了访问的网络特征，但调用的<code>CreateServiceA</code>进行持久化特征还未发现，接下来回到声明字符串处继续查找</p><p>跟进<code>Malservice</code>,确定该字符串为创建服务名称</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191612478.png" alt="image-20220419161242300"></p><p>与他们一起声明的还有<code>HGL345</code>，确定了该字符串为运行时实例的名称</p><p><img src="https://cdn.jsdelivr.net/gh/Carzy-feng/images@main/data/202204191616700.png" alt="image-20220419161639520"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/19/hello-world/"/>
    <url>/2022/04/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
